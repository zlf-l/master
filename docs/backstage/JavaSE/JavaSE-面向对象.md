# JavaSE-OOP

[>>操作指南](guide.md)

## 1、Java程序运行机制

### 1.1 编译

![image-20210414111545584](img/image-20210414111545584.png)

> Java Compiler 即是我们在安装 JDK 的时候，自带的编译工具，我们可以使用 javac 来进行调用：**javac FinalMain.java**

### 1.2 运行

编译产生的 Java 字节码，是和操作系统无关的，我们可以在任意操作系统运行，前提是这个系统安装了 Java 运行环境（ JRE ，`Java Runtime Environment`），JRE 中有一个组件叫 Java 虚拟机（ JVM ，`Java Virtual Machine` ），会将 Java 字节码转换为当前操作系统的原生代码，而这个原生代码是可以被当前操作系统理解并直接执行的代码。

![image-20210414112609275](img/image-20210414112609275.png)

> JVM 正是 Java程序无需安装、跨平台的原因，这是 Java 程序最大的特点之一(JVM消除不同操作系统的差异性)。
>
> 可以通过如下指令来执行字节码：**java com.thinkaboutai.Main**

## 2、数据类型

### 2.1 变量与常量

使用变量来在内存中临时保存数据。

> 变量的命名规则需遵循驼峰命名法

常量，即不能修改的变量，需使用 `final` 进行修饰

### 2.2 引用类型数据

在 Java 中，除开值类型以外的数据类型，都是引用类型数据，用来存储一些较为复杂的数据，例如对象。

> 区别
> 1. 值类型在传递的时候，拷贝的是值：每一个变量的值都是独立存储的，因此，修改一个变量的时候，不会影响其它的变量。
> 2. 引用类型在传递的时候，拷贝的是对象引用的地址：当两个变量的值存储的是同一个对象的引用的时候，通过一个变量修改这个对象的值，会影响到引用这个对象的其它变量。

### 2.3 String

字符串就是字符的序列，我们除开可以使用 `new` 来进行实例化以外，还可以使用字符串字面量（ `Literal` ）来进行创建。

> 注意：由于字符串是不可变（ immutable ）对象，因此其方法不会修改原有字符串，都是通过返回值（如有）的方式返回修改以后的字符串

**转义字符，用来表示或者转换一些特殊的字符串**

### 2.4Array

可以使用数组来保存一系列的列表项，通过下标来访问数组的每一个元素，也可以对其进行赋值。`Arrays` 是 `JDK` 提供的一个用于操作数组的工具类，里面包含了很多常用的数组方法。还可以使用字面量来对数组直接进行初始化。

### 类型转换

向上转换不会发生数据丢失，是无损转换。

向下转换会发生数据丢失。发生转换成存储空间更小的类型

> 向上和向下转换都只能用于可互相转换的类型之间，例如数字类型之间的互相转换，但字符串不可以转换为数字。

##  逻辑操作符

逻辑操作符可以用来组合多个布尔值或布尔表达式

> && 逻辑与 表示两者同时满足
> || 逻辑或 表示两者满足其一即可
>  ! 取反

## OOP（面向对象编程）

### 介绍

**面向过程编程**：是分析问题解决的过程 ，通过函数把过程一步一步实现，在使用时通过调用相关函数即可。(做一件事，分为多个步骤，每个步骤之间是有序的，最后按序完成）

优点：性能高。

缺点：维护和扩张困难、代码复用性差。

**面向对象编程**：把一个问题拆分成多个小的对象，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。

优点：易维护、易复用、易扩展。

缺点：比于面向过程性能低。

**三大基本特征**：即封装、继承和多态。

### 类(class)与对象

* class(类)：是一组相关**属性**和**行为**的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该 类事物。也可以理解为是blueprint（蓝图），是用来创建对象的图纸。

  **属性**：就是该事物的状态信息。

  **行为**：就是该事物能够做什么。

* object(对象)：对象是类的一个**实例**（instance），必然具备该类事物的属性和行为。

#### 类的定义

* 定义类：就是定义类的成员，包括成员变量和成员方法
* 成员变量：在类中，方法外。
* 成员方法：去掉static。

#### 成员变量与成员方法

* 类的成员变量为类的属性。可以是基本数据类型，也可以是引用类型。格式如下：

  ~~~java
  		[修饰符]  数据类型  变量名 [=初始值];  
  ~~~

  说明：

  1. 与类修饰符一样，某些修饰符可以同时放在一起，有些则不能。
  2. 在定义类的成员变量时，可以同时赋初值；要想操作成员变量，必须放到方法中。

* 类的方法是用来定义类的行为，在方法中通过操作类的成员变量、编写业务逻辑、返回 结果等实现类的业务行为。方法也是类与外界交互的重要窗口。格式如下：

  ~~~java
   [修饰符]  返回值的数据类型  方法名(参数1，参数2，…，参数 n){//n可以=0  
   			… …          //方法体(可以定义变量（局部变量）、编写控制流程等操作，用于实现类的行为，也 即实现方法的目的。)
   } 
  ~~~

  #### 修饰符

  | 修饰符       | 含义                                                         |
  | :----------- | ------------------------------------------------------------ |
  | public       | 公有访问修饰符，公共类，对所有类可见。                       |
  | private      | 私有访问修饰符，在同一类内可见。                             |
  | private      | 受保护的访问修饰符，对同一包内的类和所有子类可见。           |
  | default      | 默认访问修饰符，在同一包内可见，不使用任何修饰符。           |
  | final        | 最终修饰符，修饰的变量为常量，是不可修改的。                 |
  | static       | 静态修饰符。static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然 后计算这些数据。 |
  | abstract     | 抽象修饰符，只有方法头，无方法体。 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成final和static。 |
  | synchronized | 同步修饰符，`synchronized`关键字声明的方法同一时间只能被一 个线程访问。 |
  | native       | 本地修饰符，表示方法体是由其他语言在程序外部完成的。         |

#### 成员变量与局部变量的区别

1. 语法上
   成员变量是定义在类中 、方法之外的变量；局部变量是定义在类的方法中的变量，包括 方法参数。 成员变量可以被访问修饰符和静态修饰符修饰，局部变量不行。
2. 存储方式上
   成员变量是对象的一部分，在对象创建时，一同保存在堆区；局部变量保存在栈区。
3. 生存周期上
   成员变量与对象一起产生、一起消亡；局部变量只有当对象调用方法时起产生，调用方 法结束时局部变量消亡。
4. 初始化情况
   即使没有对成员变量显式赋值，系统也会给它们赋一个默认值；局部变量则不行， 必须为它们赋值。

#### 对象与类的关系

* 类是抽象的，不是具体的，类只是负责把事物描述起来，提供模板；对象是类的实例化，是具体的；定义好一个Java类后需要通过对象将类进行实例化

* 类是对一类事物的描述，是抽象的。

* 对象是一类事物的实例，是具体的。

* 类是对象的模板，对象是类的实体。

#### 内存分配

* JVM内存，总共分为5大内存区域，寄存器、本地方法栈、方法区、栈内存（虚拟机栈）、堆内存；和我们程序员有关的为方法区、栈内存、堆内存；
  * 方法区：存储类的信息（有多少变量、方法、是什么修饰符修饰的等）、常量信息、静态变量等信息
  * 栈内存（VM栈）：方法调用时进栈内存执行，也就是方法运行时消耗的内存；
  * 堆内存：存储类的实例信息，只要是new出来的信息都存在堆内存
* 在new一个类的时候，Jvm去方法区找有没有这个class，没有就加载到方法区，属性方法这些都是在方法区class中的；Jvm加载完后，就根据这个模板在堆中创建对象给属性赋默认值，然后再执行赋值语句给对象赋值；

![](img/image-20220712200559652.png)

* 基本数据类型（值传递）：方法调用时，实参把它的值传递给对应的形参，形参只是用实参的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形参值的改变不影响实参的值，存储在栈这个区域
* 引用数据类型（引用传递[也称为传地址]）：方法调用时，实参是对象（或数组），这时实参与形参指向同一个地址，在方法执行中，对形参的操作实际上就是对实参的操作，这个结果在方法结束后被保留了下来，所以方法执行中形参的改变将会影响实参。如上图：首先计算赋值表达式的右值，也即是对象，将其保存在堆这个区域，并且得到一个内存地址（引用，例如0x10），然后将这个内存地址通过一个变量，也即赋值表达式的左值（例如tb），保存在栈这个区域。tb这个变量通过内存地址引用了保存在内存堆中的一个对象，这就是我们为什么称之为引用类型数据的原因。

> `Java`不同于 `C/C++`，它不需要通过编码释放内存，当我们执行完一个代码块，其中保存在栈区域的变量都会被移除掉。同时，后台还会有一个进程（`Garbage Collection`，简称`GC`，即垃圾回收器），随时监控堆区域，如果堆区域的对象没有被引用，那么它们也会在某个时间点被自动释放掉。
>
> 在`Java`中，除了基本数据类型之外的数据类型都是引用数据类型，都是通过`new`在堆内存开辟空间；

#### OOP 原则（封装、抽象、继承、多态）

**封装**：即把数据和操作数据的方法，打包到一个单元或者对象中。经过封装后，属性再也不是直接暴露给外部了，我们可以在外部操作属性之前加以控制。原则：将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。

**抽象**：即通过隐藏不必要的细节，来降低复杂度（降低外部调用的复杂度）。就是把一些实现的细节隐藏在类中，而是通过一些接口和方法来对它进行操作即可。(当我们不想封装一个具体的类的时候，所封装出来的类，之所以不想封装出来，是因为它的行为比较抽象无法编写出具体的逻辑)。主要是用来被继承的，它的子类必须要实现父类中的抽象方法，否则它自己也必须声明为abstract class

**继承**：即子类继承父类的特征（属性）和行为，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

继承可以使得子类盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。

* 子类继承父类可以获得父类的功能，提高代码的复用性。
* 子类可以重写（覆盖）某些父类的功能，我们一般称为增强。
* 子类除了可以继承父类的功能之外，还可以额外添加子类独有的功能，一般来说，子类要比父类强大（你的是我的，我的还是我的）。

**多态**：即事物（对象）存在的多种形态，简称多态。多态体现了程序的可扩展性、代码的复用性。（一个行为，在不同条件下，有不同的执行效果。在定义方法的时候，我们可以把参数类型定义的更为抽象一些，这样它就能接受所有的自类型实例，以此来提高程序的兼容性）。

### 比较对象

- ==用来比较两者的地址(引用)，基本类型直接比较值。
- 我们如果要实现"当这个对象中某些个属性值相等，我们就认为这是两个相同的对象"，可以使用equals。
- 重写Object的equals方法（默认比较的是地址）。

### 类型转换

- 主要分为向上（自动）和向下转型（需要在变量前面加以类型修饰）。

- 对于基本类型而言，比如数字，可以把长度小的类型自动转换成长度大的，相反，长度大的也可以强制类型转化为长度小的。

- 当把子类型转换为父类型的时候，这个实例的行为会变成它只能调用父类型声明的那些方法（能做什么看左边的类型，具体怎么做，看右边是什么样的实例）。

- 变量名+ instanceof +类型：前者是后者这个类型的一个实例吗？

  > `instanceof`是 `Java` 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 `boolean`的数据类型。
  >
  > `instanceof`是`Java`中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。
  >
  > `instanceof`一般用于对象类型强制转换
  >
  > `null`用`instanceof`跟任何类型比较时都是false
  >
  > 特别说明：
  >
  > - 类的实例包含本身的实例，以及所有直接或间接子类的实例。
  > - `instanceof`左边显式声明的类型与右边操作元必须是同种类或存在继承关系，也就是说需要位于同一个继承树，否则会编译错误。

### 关键字(this、abstract、static、final)

**this**：是Java中的一个关键字，代表所在类的当前对象的引用（地址值），即对象自己的引用.。

>  方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。

**abstract**：所谓的抽象类，就是我们不想具体化一个类型所封装出来的类型。

> 1、不能实例化的。
> 2、抽象类存在的意义，他就是用来被继承或扩展的。
> 3、抽象类中不一定有抽象方法，但是有抽象方法一定它就是抽象类。
> 4、抽象类中也可以有具体的方法。
> 5、**抽象类的子类不一定非要实现父类型中的抽象方法，它可以继续声明自己也是抽象的。**
>
> 说明：
>
> * abstract不能与final修饰同一类。
> * 在某些情况下，public、default可与abstract、final等非访问修饰符联合使用。

**static**：在类中，用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。

* static修饰的成员变量和方法，从属于类
* 普通变量和方法从属于对象
* 静态方法不能调用非静态成员，编译会报错

> 1. `static`修饰的变量(属性)，全局公用（这个类的所有实例共有的）,它不依赖类的实例而存在，类只要一加载就存在了。一般直接通过类名进行调用，它是这个类的实例所有共有的（它只有一份）。
> 2. `static`修饰方法，静态方法只能引用静态属性（在引用非静态属性的时候，这个this没有指向）
> 3. `static`方法只能引用静态变量和静态方法
> 4. `static`一般都"只执行一次"或者"只有一份"
> 5. 静态代码块：只执行一次，并且时间点在构造器之前，在静态属性初始化之后
>
> ##### **用途：方便在没有创建对象的情况下进行调用(方法/变量)。**static可以用来修饰类的成员方法、类的成员变量，另外也可以编写static代码块来优化程序性能
>
> 静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法和静态成员变量。

**fianl**：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

> 1. 被`final`修饰的变量，具有"不可改变"的特性
> 2. 修饰基本类型：其值不可以再进行修改
> 3. 修饰引用类型(可以改但地址没变)，而使用`new`一定是在内存中创建了一个新对象，所以地址会改变，如果通过setter进行修改，地址没有改变
> 4. 修饰类：这是这个类的最终版，不能被扩展和继承
> 5. 修饰方法：这是这个方法的最终版，不能被重写
> 6. final修饰的变量可以在构造器中进行第一次赋值初始化，但只能第一次去赋值初始化

### 构造方法

* 如果不提供构造方法，系统会给出无参数构造方法。
* 如果提供了构造方法，系统将不再提供无参数构造方法。
* 构造方法是可以重载的，既可以定义参数，也可以不定义参数。

> 构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void。

### 接口

接口：主要是用来封装一揽子抽象方法的，它侧重在于对行为的一种抽象（动词）。（是当我们去抽象对象的行为时，所封装的类型，它本质上是定义了一种行为的契约、规约，因为我们从接口中定义的抽象方法上，只能看到方法的参数input，还有返回类型output）

语法特点：

1. 接口中主要定义的是方法，而且默认都是public abstract。
2. 它也能定义变量（属性），但是都是默认public final static，并且必须要对其进行初始化。
3. 接口可以被类所实现，实现它的时候，需要实现其中所有的抽象方法，否则，这个类必须声明为abstract class。
4. 接口中不能有具体的方法实现，它只是一种行为的规约（规范和约定）。
5. 接口可以继承其它接口（继承多个），达到复用方法的定义。
6. 其他类在implements接口的时候，可以实现多个接口。
7. 接口中也可以定义带方法体的default方法。
8. 接口可以说是抽象类抽象到极致的一种特殊情况。

用法：

1. 接口最主要的作用是为了解耦的，可以把紧密耦合的两个东西（执行者、主体/主体所执行的行为）变成松耦合。

   ~~~java
   new User("Jack").eat();
   new Animal("Pony").eat();
   ~~~

   把eat这个单独定义成接口中的一个方法，让不同的类型来实现这个接口，最终达到主体和行为之间的松耦合

2. 形成多态

3. 接口最终形成了一种跨界类型

接口与抽象类：

![image-20210601233451636](img/image-20210601233451636.png)

> 抽象类与接口的区别：
>
> 1. 抽象类既有抽象方法也有具体方法；接口中主要都是抽象方法（除default方法）
> 2. 抽象类中可以定义成员变量，而接口中只能定义常量
> 3. 抽象类只能被单继承，而接口可以被实现多个
> 4. 抽象类体现的是is a的关系，而接口体现的是like a的关系
>
> 接口和其他类型之间的关系：
>
> * 接口和实现类之间的是implements
> * 接口和接口之间是extends
>
> 面向接口设计的好处：
>
> * 面向接口设计方法，可以极大提高方法的兼容性
> * 灵活切换实现方式
> * 是的程序更容易扩展，同时最小化扩展带来的负面影响
> * 更容易进行独立的单元测试

## Object类

1. Object 是所有的类的超类、基类。位于继承树的最顶层。
2. 任何⼀个没有显⽰定义extends⽗类的类。都直接继承Object，否则就是间接继承
3. 任何⼀个类都可以享有Object提供的⽅法
4. Object类可以代表任何⼀个类(多态)，可以作为⽅法的参数、⽅法的返回值

### Object中常⽤⽅法

#### getClass方法

此⽅法⽤于返回该对象的真实类型(运⾏时的类型)

> public final Class getClass()

#### hashCode⽅法

1. 返回该对象的⼗进制的哈希吗值
2. hash值是由hash算法通过对象的地址、对象中的字符串、数字等，计算出来的 
3. 相同的对象应当返回相同的哈希吗值，不同的对象尽量返回不同的哈希码值

> public native int hashCode(); 

#### toString⽅法

返回对象的字符串表现形式   

用于开发人员调试程序，在程序的某一个特定的地方检测对象的值

> * 全限定名+@+⼗六进制的hash值(地址)
>
> * 如果直接输出⼀个对象，那么默认会调⽤这个对象的toString⽅法，⽽toString⽅法是Object类提供的，返 回的是“对象的地址” 。但是我们⼀般输出对象希望输出的是对象的属性信息，所以可以重写⽗类的 toString⽅法

#### equals⽅法

* Object类的equals⽅法的作⽤是⽐较两个对象是否相等。⽐较的是内存地址。其底层代码的是== 

* 如果不想⽐较内存地址，那么需要重写equals⽅法

> 1. 重写equals⽅法：可以通过快速生成重写。
> 2. hashCode() ：散列算法，和雪花算法有点近似，但有细节区别，最主要是为了保证所有的元素计算出来的值，不会发生碰撞。
> 3. 开发人员可以考虑重写父类型的equals方法，来实现属性值的比较
> 4. 最佳实践：我们在重写的时候，一般equals和hashCode一起重写，主要是为了进行更严谨的比较，避免出现内存泄漏（数据创建出来以后，程序访问不到这个对象，地址丢失）
>
> == 和 equals的区别：
>
> 1. 两个东西都是⽤于⽐较的 
> 2. == 可以⽤于基本类型和引⽤类型 
> 3. equals只能⽤于引⽤类型的⽐较

## Number类

Byte、Short、Integer、Long、Float、Double六个⼦类 

提供⼀组⽅法,⽤于将其中某⼀种类型转换成其他类型 xxxValue()⽅法

## 包装类

1. 因为基本数据类型不具有⽅法和属性。⽽引⽤数据类型可以拥有属性和⽅法，使⽤更加的灵活 
2. 所以Java给8种基本数据类型提供对应8个包装类。包装类也就是引⽤数据类型

![image-20220719162203584](img/image-20220719162203584.png)

### 装箱和拆箱

1. 装箱就是将基本类型转换成包装类 
2. 拆箱就是将包装类型转换成基本类型

jdk1.5 之前装箱和拆箱

![image-20220719162306571](img/image-20220719162306571.png)

jdk1.5 之后的装箱和拆箱

![image-20220719162326351](img/image-20220719162326351.png)

## 缓冲区

整数型包装类缓冲区：整数型的包装类定义缓冲区(-128~127)，如果定义的数在这个范围你之内，那么直接从缓存数组中获取，否则，重新new新的对象

## String类

1. String 类代表字符串。 Java程序中的所有字符串⽂字（例如 "abc" ）都被实现为此类的实例。 
2. String 字符串被创建就不能修改。

### String创建对象

1. 直接赋值 
2. 通过构造⽅法创建对象

### String类常⽤⽅法

* **charAt(index)** 获取指定下标对应的字符，返回char类型

* **indexOf("字符串")** 获取指定字符串在原字符串中的下标,如果不包含该字符串则返回-1
* **lastIndexOf("字符串"**) 与indexOf⽅法⼀致，区别：从后往前找
* **length()** 获取字符串的⻓度
* **equals()** 判断两个字符串是否相等
* **equalsIgnoreCase()** 判断两个字符串是否相等,忽略⼤⼩写
* **isEmpty()** 判断字符串是否为空串
* **startsWith("指定字符")** 判断字符串是否以指定的字符串开头
* **startsWith("ab", 2)** 判断字符串是否以指定的字符串开头,指定开始位置
* **endsWith("ab")** 判断字符串是否以指定的字符串结尾
* **contains("SB")** 判断字符串中是否包含⾃定的字符串
* **str.concat("world")=str + "world"** 将字符串与指定的字符串进⾏拼接
* **.replace("SB", "!!")** 字符串替换：将字符串中指定的字符串替换成指定的字符串
* **substring(0, 5)**  字符串截取，从指定的下标开始和结束 (范围是左闭右开)
* **substring(6)**字符串截取，从指定的下标开始⼀直到最后
* **split(" ")**  字符串切割，按照指定的字符串对原字符串进⾏切割
* **trim()**  去除字符串前后的空格
* **toUpperCase()**  将字符串中的字⺟变成⼤写
* **toLowerCase()**   将字符串中的字⺟变成⼩写

### 可变字符串

1. StringBuffer
2. StringBuilder

### StringBuffer、StringBuilder类

常⽤⽅法 

* append(String str)：在字符串的后⾯追加字符串
* delete(int start, int end) ：删除字符串，从指定的下标开始和结束
* insert(int offset, String str)： 在指定下标位置添加指定的字符串
* reverse() ：将字符串翻转
* toString()：将StringBuffer转换成String类型

### String、StringBuffer、StringBuilder区别

* 这三个类都可以⽤于表⽰字符串 

  1. String类是字符串常量类，⼀旦定义不能改变 
  2. StringBuffer、StringBuilder是可变的字符串,⾃带有缓冲区。默认缓冲区⼤⼩16个字符 
  3. StringBuffer是线程安全的，所以效率低 StringBuilder是线程不安全的，所以效率⾼ 

  总结：在⼤量的字符串拼接的时候，使⽤ StringBuffer、StringBuilder。⽽不考虑线程安全的时候，选择 StringBuilder，否则选择StringBuffer



## 其他

【ORM】 Object Relational Mapping `Java Persistent API`、`Hibernate(Gavin King)`、`Mybatis`、`MybatisPlus`、`Spring`
 把面向关系的数据转换为面向对象的数据

我们的MySQL是一个面向关系的DBMS，又称为RDBMS，所以里面的表，都是依赖主外键关联的，

* 数据的最小单元，就是值，它们是是存放在表中的列上(column)的，对应实例的某一个属性(field、property)
* 表中的一行(row)数据对应OOP中某一个类的实例(instance)
*  一张表对应OOP的一个class类型
