# JDBC-高级

## 工具类封装

### 代码复用性

> 在我们的应⽤程序中，如果需要完成相同的操作，相同的代码⽆需重复编写，我们只需⼀次编写多
> 次调⽤即可
> JDBC数据库编程的步骤：
> 1. 注册驱动
> 2. 创建连接
> 3. 编写SQL
> 4.  获取Statement对象 
> 5.  执⾏SQL
> 6. 处理结果
> 7. 关闭连接

### ⼯具类封装

> DBManager
>
> DBUtil
>
> JDBCUitl
>
> DBHelper

## DAO与DTO的封装

> * DAO Data Access Object 数据访问对象 
> * DTO Data Transfer Object 数据传输对象（实体类） ⽤于传输DML操作参数及DQL的查询结果

### CRUD⽅法的封装

> * 封装是⾯向对象的特征之⼀ 
> * 我们将能够完成某个CRUD操作的代码单独定义成⼀个⽅法，当需要完成此CRUD操作时调⽤这个⽅ 法即可

### DTO实体类封装

> * 问题：在封装CRUD⽅法时，对于查询操作⽽⾔，需要将查询到的数据库记录返回给调⽤者，但是⼀ 个查询⽅法只能返回⼀个值，⽽⼀条数据库记录有多个值，如何将⼀条数据库记录的多个值返回
> * 解决办法：在Java程序中创建⼀个属性与数据库表匹配的类，通过此类的对象封装查询到的数据， 我们把⽤于传递JDBC增删查改操作的数据的对象称之为 `数据传输对象`
> * DTO(实体类：带有属性，其对象可以存放数据的类)
>
> 实体类创建规则:
>
> 1. 类中属性的个数和类型，与对应的数据表保持⼀致 
> 2. 提供所有属性的get和set⽅法 
> 3. 提供全参构造器 
> 4. 提供⽆参构造器
> 5. 重写toString⽅法 
> 6. 重写hashcode和equals 
> 7. 实现序列化Serializable接⼝

### 实体类传递添加、修改操作参数

在JDBC的添加、修改等⽅法中需要多个数据，我们可以通过实体类来进⾏参数传递

### DAO类封装

DAO封装：将对数据库中同⼀张数据表的JDBC操作⽅法封装到同⼀个Java类中，这个类就是访问此 数据表的 `数据访问对象`

### DAO类代码优化

1. 在应⽤程序开发中，如果⽅法中抛出异常且⾃⼰可以处理，则直接通过try/catch进⾏捕获处理； 
2. JDBC操作⽅法的连接需要放在finally中进⾏关闭； 
3. 将数据库连接Connection、Statement、ResultSet等需要关闭的数据库对象定义在try之前; 
4. 因为所有的JDBC操作都需要Conection、Statement对象，查询⽅法都需要ResultSet对象，因 此在DAO中可以将这些对象定义成类的成员变量

## JDBC事务管理

事务指逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。

### 事务的特性：ACID

* 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
* 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。
* 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
* 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

### 事务的隔离级别

| 事务隔离级别     | Lost Updates | Dirty Reads | Non-repeating Reads | Phanton Reads |
| ---------------- | ------------ | ----------- | ------------------- | ------------- |
| Read Uncommitted |              |             |                     |               |
| Read Committed   |              | Y           |                     |               |
| Repeatable Read  | Y            | Y           | Y                   |               |
| Serializable     | Y            | Y           | Y                   | Y             |

注意：空的为允许，Y为不允许。

事务隔离级别越高，使用的锁也会越多，越需要牺牲性能和体验

### 并发带来的问题

> - `Lost Updates`丢失修改：当2个事务修改同一份数据而不使用锁时，会发生这种情况，后一个事务的修改会把前一次事务的修改覆盖掉。
>
>   > 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了由其他事务所做的更新
>
> - `Dirty Reads`脏读：事务读取还没有提交的数据时，事务A对数据发生了修改，而事务B在A提交之前读取了A修改的数据，但是最后A回滚了，那么B读取的数据就是无效的。
>
>   > 脏读是指在⼀个事务处理过程⾥读取了另⼀个未提交的事务中的数据。也就是不能读到前⼀个事务未完成,未commit的数据。只有commit后才能读到更新后的数据，没有commit，则还是之前的数据。
>
> - `Non-repeating Reads`不可重复读：在一次事务A中2次读取同一份数据，但是事务B在A的2次读取之间对这份数据进行了修改和提交，那么事务A的2次读取结果将会不一样。简言之，一个事务读取同一条记录，会出现两个不同的状态值，又称为ABA事件。
>
>   > 在当前线程内，多次读，结果不⼀致(读到了另⼀事务`update`的数据)
>   >
>   > 不可重复读是指在对于数据库中的某个数据，⼀个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另⼀个事务修改并提交了,主要是针对update。
>
> - `Phanton Reads`幻读：事务B对数据进行了修改，在B提交之前，事务A根据条件查询出若干条记录，但是在B提交之后，使得某些数据之前不符合A的要求，但是B修改提交后符合要求了。
>
>   > 在当前线程内，多次读，结果不⼀致(读到了另⼀事务`insert`的数据)
>   >
>   > 例如事务A对⼀个表中所有的⾏的某个数据项做了从“1”修改为“2”的操作，这时事务B⼜对这个表中插入了⼀⾏数据项，⽽这个数据项的数值还是为“1”并且提交给数据库。⽽操作事务A的⽤户如果再查看刚刚修改的数据，会发现还有⼀⾏没有修改，其实这⾏是从事务B中添加的，就好像产⽣幻觉⼀样，这就是发⽣了幻读。幻读主要是针对insert与delete。

### 隔离级别

> * 读未提交【Read Uncommitted】： 在该隔离级别，所有的事务都可以看到其他事务没有提交的执行结果。这也被称为脏读。
> * 读提交【Read Committed】 ：该隔离级别是大多数数据库的默认的隔离级别（不是 MySQL 默认的）。它满足了隔离的简单定义:一个事务只能看到其他的已经提交的事务所做的改变。
> * 可重复读【Repeatable Read】： 这是 MySQL 默认的隔离级别，它确保同一个事务，在执行中，多次读取操作数据时，会看到同样的数据行。但是会有幻读问题。
> * 串行化【Serializable】: 这是事务的最高隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决了幻读的问题。

### MySQL事务管理

https://zengyihong.blog.csdn.net/article/details/123588551

> start transaction–开启事务
> savepoint 保存点名–设置保存点
> rollback to 保存点名–回退事务
> rollback–回退全部事务
> commit-提交事务

### JDBC事务管理

> 1. ⼀个事务中的多个DML操作需要基于同⼀个数据库连接 
> 2. 创建连接之后，设置事务⼿动提交（关闭⾃动提交 connection.setAutoCommit(false); 
> 3. 当当前事务中的所有DML操作完成之后⼿动提交 connection.commit();
> 4.  当事务中的任何⼀个步骤出现异常，在catch代码块中执⾏事务回滚 connection.rollback();

### Service层的事务管理

DAO只负责数据库的操作，业务由service层进⾏管理

#### Service层

> * DAO负责特定的数据库操作 
> * Servcie进⾏业务处理，Service业务处理过程如果需要数据库操作，则调⽤DAO完成

#### Service层的事务管理

> Servcie层事务中多个数据库的DML操作是相互独⽴的，如何保证所有DML要么同时成功，要么同时 失败呢？ 
>
> 事务管理要满⾜以下条件：
>
> * 多个DML操作需使⽤同⼀个数据库连接 
> * 第⼀个DML操作之前设置事务⼿动提交 
> * 所有DML操作执⾏完成之后提交事务
> * 出现异常则进⾏事务回滚

**如何让Service事务中的多个DML使⽤同⼀个数据库连接**

* 在Service获取连接对象，将连接对象传递到DAO中

  > 分析：DAO类中的Connection对象需要通过Service传递给进来，这种对象传递本来也⽆可厚⾮， 但是当我们通过⾯向接⼝开发时（⾯向接⼝，是为了能够灵活的定义实现类），容易造成接⼝的冗 余（接⼝污染）

* 使⽤ThreadLocal容器，实现多个DML操作使⽤相同的连接

  > 存储Connection的容器可以使⽤List集合
  >
  > * 使⽤List集合做容器，在多线程并发编程中会出现资源竞争问题，多个并发的线程使⽤的是同⼀ 个数据库连接对象（我们的要求是同⼀个事务中使⽤同⼀个连接，⽽并⾮多个线程共享连接） 
  > * 为了解决并发编程的连接对象共享问题，我们可以使⽤ThreadLocal作为数据库连接对象的

