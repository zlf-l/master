# Java基础

## 1.final关键字的作用

被final修饰的类不可以被继承，被final修饰的方法不可以被重写，被final修饰的变量不可以被改变.如果修饰引用，那么表示引用不可变，引用指向的内容可变.被final修饰的方法，JVM会尝试将其内联，以提高运行效率，被final修饰的常量，在编译阶段会存入常量池中。

## 2.abstractclass和interface有什么区别

声明方法的存在而不去实现它的类被叫做抽象类（abstractclass），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。

接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义staticfinal成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof运算符可以用来决定某对象的类是否实现了接口。

## 3.Java集合类：list、set、queue、map、stack的特点与用法

**Map**

Map是键值对，键Key是唯一不能重复的，一个键对应一个值，值可以重复。

TreeMap可以保证顺序，HashMap不保证顺序，即为无序的，Map中可以将Key和Value单独抽取出来，其中KeySet()方法可以将所有的keys抽取成一个Set，而Values()方法可以将map中所有的values抽取成一个集合。

**Set**

不包含重复元素的集合，set中最多包含一个null元素，只能用Iterator实现单项遍历，Set中没有同步方法。List有序的可重复集合，可以在任意位置增加删除元素，用Iterator实现单向遍历，也可用ListIterator实现双向遍历。

**Queue**

Queue遵从先进先出原则，使用时尽量避免add()和remove()方法，而是使用offer()来添加元素，使用poll()来移除元素，它的优点是可以通过返回值来判断是否成功，LinkedList实现了Queue接口，Queue通常不允许插入null元素。

**Stack**

Stack遵从后进先出原则，Stack继承自Vector，它通过五个操作对类Vector进行扩展，允许将向量视为堆栈，它提供了通常的push和pop操作，以及取堆栈顶点的peek()方法测试堆栈是否为空的empty方法等。

**用法**

如果涉及堆栈，队列等操作，建议使用List。

对于快速插入和删除元素的，建议使用LinkedList。

如果需要快速随机访问元素的，建议使用ArrayList。

## 4.ArrayList，Vector，LinkedList的存储性能和特性

ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

## 5.内存泄漏和内存溢出

内存泄漏(memoryleak)，是指应用程序在申请内存后，无法释放已经申请的内存空间，一次内存泄漏危害可以忽略，但如果任其发展最终会导致内存溢出（outofmemory）。如读取文件后流要进行及时的关闭以及对数据库连接的释放。

内存溢出(outofmemory)，是指应用程序在申请内存时，没有足够的内存空间供其使用。如我们在项目中对于大批量数据的导入，采用分批量提交的方式。

## 6.反射中，Class.forName()和ClassLoader.loadClass()的区别

Class.forName(className)方法，内部实际调用的方法是Class.forName(className，true，classloader)；第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化，一旦初始化，就会触发目标对象的static块代码执行，static参数也也会被再次初始化。

ClassLoader.loadClass(className)方法，内部实际调用的方法是ClassLoader.loadClass(className，false)；第2个boolean参数，表示目标对象是否进行链接，false表示不进行链接，由上面介绍可以，不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行。

## 7.Int和Integer的区别

Integer是int的包装类型，在拆箱和装箱中，二者自动转换.int是基本类型，直接存数值；而integer是对象；用一个引用指向这个对象.由于Integer是一个对象，在JVM中对象需要一定的数据结构进行描述，相比int而言，其占用的内存更大一些.

## 8.String、StringBuilder、StringBuffer区别

String字符串常量不可变使用字符串拼接时是不同的2个空间

StringBuffer字符串变量可变线程安全字符串拼接直接在字符串后追加

StringBuilder字符串变量可变非线程安全字符串拼接直接在字符串后追加

> 1. StringBuilder执行效率高于StringBuffer高于String.
> 2. String是一个常量，是不可变的，所以对于每一次+=赋值都会创建一个新的对象，StringBuffer和StringBuilder都是可变的，当进行字符串拼接时采用append方法，在原来的基础上进行追加，所以性能比String要高，又因为StringBuffer是线程安全的而StringBuilder是线程非安全的，所以StringBuilder的效率高于StringBuffer.
> 3. 对于大数据量的字符串的拼接，采用StringBuffer，StringBuilder.

## 9.Hashtable和Hashmap的区别

HashTable线程安全，HashMap非线程安全

Hashtable不允许null值(key和value都不可以)，HashMap允许null值(key和value都可以)。

两者的遍历方式大同小异，Hashtable仅仅比HashMap多一个elements方法。

## 10.几个常见的编译时异常

SQLException提供有关数据库访问错误或其他错误的信息的异常。

IOexception表示发生了某种I/O异常的信号。此类是由失败或中断的I/O操作产生的一般异常类

FileNotFoundException当试图打开指定路径名表示的文件失败时，抛出此异常。

ClassNotFoundException找不到具有指定名称的类的定义。

EOFException当输入过程中意外到达文件或流的末尾时，抛出此异常。

## 11.方法重载的规则

方法名一致，参数列表中参数的顺序，类型，个数不同。重载与方法的返回值无关，存在于父类和子类，同类中。可以抛出不同的异常，可以有不同修饰符。

## 12.方法重写的规则

参数列表方法名返回值类型必须完全一致，构造方法不能被重写；声明为final的方法不能被重写；声明为static的方法不存在重写(重写和多态联合才有意义)；访问权限不能比父类更低；重写之后的方法不能抛出更宽泛的异常

## 13.throw和throws的区别

**throw**

throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。throw是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行throw一定是抛出了某种异常。

**throws**

throws语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。throws主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。throws表示出现异常的一种可能性，并不一定会发生这种异常。

## 14.抽象类和接口的区别

1. 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
2. 类可以实现很多个接口，但是只能继承一个抽象类
3. 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
4. 抽象类可以在不提供接口方法实现的情况下实现接口。
5. Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
6. Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protecte或者是public。
7. 接口是绝对抽象的，不可以被实例化(java8已支持在接口中实现默认的方法)。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。

## 15.Java的基础类型和字节大小

布尔型boolean8位；字节型byte8位；字符型char16位；短整型short16位；整形int32位；长整形long64位；浮点型float32位；双精度double64位；

## 16.四个访问修饰符合访问级别

Protected、public、没有访问修饰符、private

## 17.String和StringBuffer的区别

String和StringBuffer主要区别是性能：String是不可变对象，每次对String类型进行操作都等同于产生了一个新的String对象，然后指向新的String对象.所以尽量不要对String进行大量的拼接操作，否则会产生很多临时对象，导致GC开始工作，影响系统性能.StringBuffer是对象本身操作，而不是产生新的对象，因此在有大量拼接的情况下，我们建议使用StringBuffer(线程安全).

## 18.HashSet的底层实现

HashSet的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。在HashSet的构造法中会初始化一个HashMap对象，HashSet不允许值重复。

因此，HashSet的值是作为HashMap的key存储在HashMap中的，当存储的值已经存在时返回false。

## 19.抽象类的意义

抽象类的意义可以用三句话来概括：

1为其他子类提供一个公共的类型

2封装子类中重复定义的内容

3定义抽象方法，子类虽然有不同的实现，但是定义时一致的

## 20.为什么重写equals时必须重写hashCode方法

hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。如果两个对象相等，则hashcode一定也是相同的如果两个对象相等，对两个对象分别调用equals方法都返回true如果两个对象有相同的hashcode值，它们也不一定是相等的因此，equals方法被覆盖过，则hashCode方法也必须被覆盖。

hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等(即使这两个对象指向相同的数据).

## 21.HashSet和TreeSet有什么区别

HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。

## 22.强引用、软引用、弱引用以及虚引用

**强引用**

最普遍的一种引用方式，如Strings="abc"，变量s就是字符串“abc”的强引用，只要强引用存在，则垃圾回收器就不会回收这个对象。

**软引用(SoftReference)**

用于描述还有用但非必须的对象，如果内存足够，不回收，如果内存不足，则回收。一般用于实现内存敏感的高速缓存，软引用可以和引用队列ReferenceQueue联合使用，如果软引用的对象被垃圾回收，JVM就会把这个软引用加入到与之关联的引用队列中。

**弱引用(WeakReference)**

弱引用和软引用大致相同，弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

**虚引用(PhantomReference)**

就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。

**虚引用与软引用和弱引用的一个区别在于**：

虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

## 23.数组在内存中如何分配

当一个对象使用new关键字创建的时候，会在堆上分配内存空间，然后才返回到对象的引用。这对数组来说也是一样的，因为数组也是一个对象，简单的值类型的数组，每个数组成员是一个引用(指针)引用到栈上的空间。

## 24.Java中怎么创建一个不可变对象

1. 对象的状态在构造函数之后都不能被修改，任何修改应该通过创建一个新对象来实现.

2. 所有的对象属性应该都设置为final

3. 对象创建要正确，例如：对象的应用不能在构造函数中被泄露出去

4. 对象要设置为final，确保不要继承的Class修改了immutability特性

## 25.Java中++操作符是不是线程安全

不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。

## 26.new一个对象的过程和clone一个对象的过程

new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。

clone在第一步是和new相似的，都是分配内存，调用clone方法时，分配的内存和原对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。

## 27.Java中==和equals()的区别

使用==比较原生类型如：booleanintchar等等，使用equals()比较对象。

* ==是判断两个变量或实例是不是指向同一个内存空间。equals是判断两个变量或实例所指向的内存空间的值是不是相同。

* ==是指对内存地址进行比较。equals()是对字符串的内容进行比较。
* ==指引用是否相同，equals()指的是值是否相同。

## 28.final、finalize和finally的不同之处

final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。

finally是异常处理语句结构的一部分，表示总是执行。

finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。

## 29.Java的多态表现在哪里

多态要有动态绑定，否则就不是多态，方法重载也不是多态（因为方法重载是编译期决定好的，没有后期也就是运行期的动态绑定）

当满足这三个条件：

1. 有继承
2. 有重写
3. 要有父类引用指向子类对象

## 30.静态类型有什么特点

静态的属性：随着类的加载而加载，该属性不在属于某个对象，属于整个类

静态的方法：直接用类名调用，静态方法里不能访问非静态成员变量

静态类：不能直接创建对象，不可被继承

## 31.Java创建对象的几种方式

new创建新对象；通过反射机制；采用clone机制；通过序列化机制

## 32.Object中有哪些公共方法

Object是所有类的父类，任何类都默认继承Objectclone保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。equals在Object中与==是一样的，子类一般需要重写该方法。hashCode该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。getClassfinal方法，获得运行时类型wait使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(longtimeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。

## 33.&和&&的区别

&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）。

## 34.在.java源文件中可以有多个类吗（内部类除外）

一个.java源文件中可以包括多个类（不是内部类），但是单个文件中只能有一个public类，并且该public类必须与文件名相同

## 35.如何正确的退出多层嵌套循环

使用标号和break；

通过在外层循环中添加标识符

## 36.内部类有什么作用

内部类可以很好的实现隐藏，一般的非内部类，是不允许有private与protected权限的，但内部类可以

内部类拥有外围类的所有元素的访问权限

可是实现多重继承

可以避免修改接口而实现同一个类中两种同名方法的调用

## 37.深拷贝和浅拷贝的区别是什么

浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象.换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。

深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。

## 38.String是基本数据类型

基本数据类型包括byte、int、char、long、float、doubleboolean和short。

java.lang.String类是final类型的，因此不可以继承这个类不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类

## 39.static的用法

Static可以修饰内部类方法变量代码块；Static修饰的类是静态内部类；Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。

Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。

Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。

## 40.什么是值传递和引用传递

对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值，对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。

## 41.重载和重写的区别

方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。

## 42.成员变量和局部变量的区别有哪些

从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public，private，static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰；

从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存

从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。

成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。

## 43.静态方法和实例方法有何不同

静态方法和实例方法的区别主要体现在两个方面：

在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。

静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制

## 44.什么是多态

允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）

## 45.多态的优点

可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。

可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。

## 46.多态存在的三个必要条件

要有继承。

要有方法的重写。

父类引用指向子类对象（对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接）

## 47.TreeMap、HashMap、LindedHashMap的区别

LinkedHashMap可以保证HashMap集合有序。存入的顺序和取出的顺序一致。TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。HashMap不保证顺序，即为无序的，具有很快的访问速度。HashMap最多只允许一条记录的键为Null；允许多条记录的值为Null；HashMap不支持线程的同步。

## 48.Java（OOP）面向对象的特征有哪些方面

抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段

封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。

多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西

> 要实现多态需要做两件事：1.方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2.对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

## 49.列出一些常见的运行时异常

ArithmeticException（算术异常）

ClassCastException（类转换异常）

IllegalArgumentException（非法参数异常）

IndexOutOfBoundsException（下标越界异常）

NullPointerException（空指针异常）

SecurityException（安全异常）

## 50.什么是反射

反射就是动态加载对象，并对对象进行剖析。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能成为Java反射机制。

## 51.反射的作用

在运行时判断任意一个对象所属的类

在运行时构造任意一个类的对象

在运行时判断任意一个类所具有的成员变量和方法

在运行时调用任意一个对象的方法

## 52.获取class的三种方式

对象调用getClass()方法来获取；类名.class的方式得到；通过Class对象的forName()静态方法来获取

## 53.break和continue的区别

break和continue都是用来控制循环的语句。break用于完全结束一个循环，跳出循环体执行循环后面的语句。continue用于跳过本次循环，继续下次循环。

## 54.运行时异常与一般异常有何异同

异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。

## 55.ListMapSet三个接口存取元素时，各有什么特点

List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-valuepair）映射，映射关系可以是一对一或多对一

## 56.Collection和Collections的区别

Collection是集合类的上级接口，继承与他的接口主要有Set和List.

Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索排序线程安全化等操作。

## 57.Error和Exception有什么区别

error表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。

exception表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。

## 58.EJB的生命周期，以及如何管理事务

SessionBean：Stateless SessionBean的生命周期是由容器决定的，当客户机发出请求要建立一个Bean的实例时，EJB容器不一定要创建一个新的Bean的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户机第一次调用一个Stateful  SessionBean时，容器必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用Stateful SessionBean的方法时容器会把调用分派到与此客户机相关联的Bean实例。

EntityBean：EntityBeans能存活相对较长的时间，并且状态是持续的。只要数据库中的数据存在，Entitybeans就一直存活。而不是按照应用程序或者服务进程来说的。即使EJB容器崩溃了，Entitybeans也是存活的。EntityBeans生命周期能够被容器或者Beans自己管理。

EJB通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），SunMicrosystems的TransactionService（JTS）JavaTransactionAPI（JTA），开发组（X/Open）的XA接口。

## 59.Comparable和Comparator接口的区别

Comparable接口只包含一个compareTo()方法。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。Comparator接口包含compare()和equals()两个方法。

## 60.switch能否作用在byte、long、string上

switch可作用在char、byte、short、int

switch可作用于char、byte、short、int的包装类上

switch不可作用于long、double、float、boolean，包括他们的包装类

switch中可以是字符串类型，String（Java1.7以后才可以作用在String上）

switch可以是枚举类型（JDK1.5之后）

## 61.jdk中哪些类是不能继承的

不能继承的是类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中System，String，StringBuffer等都是基本类型。

## 62.Set里的元素是不能重复的，那么用什么方法来区分重复与否

Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。

equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。

## 63.JDK和JRE的区别是什么

Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。

Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发编译执行Java应用程序。

## 64.是否可以在static环境中访问非static变量

static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

## 65.Java支持多继承么

不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。

## 66.什么是迭代器(Iterator)

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的

迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。

克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。

## 67.Iterator和ListIterator的区别是什么

下面列出了他们的区别：

Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。

Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。

ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

## 68.Enumeration接口和Iterator接口的区别有哪些

Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比

Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。

## 69.List，Set，Map是否继承自Collection接口

只有List和Set接口继承于Collection接口，Map是与Collection并列的接口概念

## 70.字符串常量池到底存在于内存空间的哪里

jdk6.0字符串常量池在方法区，方法区的具体体现可以看做是堆中的永久区。

jdk7.0java虚拟机规范中不再声明方法区，字符串常量池存放在堆空间中

jdk8.0java虚拟机规范中又声明了元空间，字符串常量池存放在元空间中

## 71.Java中的编译期常量是什么、使用它又什么风险

公共静态不可变（publicstaticfinal）变量也就是我们所说的编译期常量，这里的public可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖JAR文件时，确保重新编译你的程序。

## 72.用哪两种方式来实现集合的排序

你可以使用有序集合，如TreeSet或TreeMap，你也可以使用有顺序的的集合，如list，然后通过Collections.sort()来排序。

## 73.JDK1.7中的三个新特性

虽然JDK1.7不像JDK5和8一样的大版本，但是，还是有很多新的特性，如try-with-resource语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java会自动关闭。Fork-Join池某种程度上实现Java版的Map-reduce。允许Switch中有String变量和文本。菱形操作符(<>)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个catch块中捕获多个异常。

## 74.JDK1.8引入的新特性

Java8在Java历史上是一个开创新的版本，下面JDK8中5个主要的特性：Lambda表达式，允许像对象一样传递匿名函数StreamAPI，充分利用现代多核CPU，可以写出很简洁的代码Date与TimeAPI，最终，有一个稳定简单的日期和时间库可供你使用扩展方法，现在，接口中可以有静态默认方法。重复注解，现在你可以将相同的注解在同一类型上使用多次。

## 75.ArrayList源码分析

（1）ArrayList是一种变长的集合类，基于定长数组实现，使用默认构造方法初始化出来的容量是10（1.7之后都是延迟初始化，即第一次调用add方法添加元素的时候才将elementData容量初始化为10）。

（2）ArrayList允许空值和重复元素，当往ArrayList中添加的元素数量大于其底层数组容量时，其会通过扩容机制重新生成一个更大的数组。ArrayList扩容的长度是原长度的1.5倍

（3）由于ArrayList底层基于数组实现，所以其可以保证在O(1)复杂度下完成随机查找操作。

（4）ArrayList是非线程安全类，并发环境下，多个线程同时操作ArrayList，会引发不可预知的异常或错误。

（5）顺序添加很方便

（6）删除和插入需要复制数组，性能差（可以使用LinkindList）

（7）Integer.MAX_VALUE-8：主要是考虑到不同的JVM，有的JVM会在加入一些数据头，当扩容后的容量大于MAX_ARRAY_SIZE，我们会去比较最小需要容量和MAX_ARRAY_SIZE做比较，如果比它大，只能取Integer.MAX_VALUE，否则是Integer.MAX_VALUE-8。这个是从jdk1.7开始才有的

## 76.HashMap源码分析

jdk1.8之前list+链表

jdk1.8之后list+链表（当链表长度到8时，转化为红黑树）

HashMap的扩容因子默认0.75，也就是会浪费1/4的空间，达到扩容因子时，会将list扩容一倍，0.75是时间与空间一个平衡值；

## 77.ConcurrentHashMap源码分析

ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。

ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护者一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。
