# Java基础

## 1、final关键字的作用

* 修饰的类不可被继承、修饰的方法不可被重写、修饰的变量不可被修改。
* 修饰引用类型，引用地址不可变，其指向的内容可以改变。
* 修饰的方法，`JVM`会将其内联，提高运行效率。
* 修饰的常量，在编译阶段会存入常量池。

## 2、abstract class 和interface的区别

* 抽象类（`abstract class`）
  * 声明方法存在而不实现的类（用于创建体现某些基本行为的类，声明该方法，却不类中实现该方法的类）。
  * 不能创建`abstract`类实例对象；可以创建一个抽象类型的变量，让其指向具体子类的实例对象。
  * 没有抽象构造方法和静态方法。
  * `Abstract`类的子类必须实现其父类声明的抽象方法，否则子类也必须声明为抽象方法。
* 接口（`interface`）
  * 抽象类的变体（抽象到极致的类）。
  * 接口中的所有方法都是抽象的（没有程序体），多继承可以通过接口实现。
  * 接口中只能定义`static final`的成员变量。
  * 接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。
  * 当类实现特殊接口时，该类定义所有这种接口的方法。然后，该类可以在实现该接口的类的任何对象上调用接口的方法。有抽象类，该类允许使用接口作为引用变量的类型。通常动态连篇生效。引用可以转换到接口类型或从接口类型转换。
  * `instanceof`运算符可以判断某对象的类是否实现了接口。

## 3、Java集合类：list、set、queue、map、stack的特点与用法

* Map
  * 以键值对方式保存数据，`Key`键唯一不重复，一个键对应一个值，值可以重复。
  * `TreeMap`有序，`HashMap`无序
  * `Map`中的`Key`和 `Value`可以单独取出，`KeySet()`方法可以将所有的`keys`抽取成`Set`对象，`Values()`方法可以将所有的`value`抽取成一个集合。
* Set
  * 没有重复的元素，最多只能包含一个`null`元素，遍历方法有`Iterator`（单向）、`ListIterator`（双向）。`Set` 中没有同步方。
* List
  * 元素可以重复，可以在任意位置增删元素，遍历方法有`Iterator`（单向）、`ListIterator`（双向）。
* Queue
  * 遵从先进先出原则，使用时尽量不使用`add()`和`remove()`方法，使用`offer()`添加元素和`pull()`移除元素，好处时可以通过返回值来判断是否成功。`LinkedList`实现了`Queue`接口，`Queue`不允许添加`null`元素。
* Stack
  * 遵从先进后出原则，`Stack`继承自`Vector`，可以通过五个操作对类`Vector`进行扩展，可以将向量作为栈堆，常用的操作`push()`、`pop()`、`peek()` 取堆栈顶点，`empty()` 判断堆栈是否为空。

> 用法
>
> * 涉及堆栈、队列，可以使用`List`。
> * 快速插入和删除元素，可以使用`LinkedList`。
> * 快速随机访问元素，可以使用`ArrayList`

## 4、OOP三个基本特征

三个基本特征：封装、继承、多态

* 继承

  发生在子类与父类之间，子类通过继承获得父类的对象属性和方法。
  
* 封装

  将不想暴露的属性或实现封装起来，通过提供的接口或方法进行访问。通过封装，对象对内部数据提供了不同级别的保护，以防止篡改或错误使用对象私有部分。

* 多态

  同一个方法有不同的表现形式。多态存在的三个条件：继承、重写、父类引用指向子类对象。

## 5、访问修饰符以及不写诗的区别

* `public`当前项目下的所有类都可以访问
* `protected`当前包下的类和所有子类都可以访问（`protected`对于子类相当于时公开的，对于不同包没有父子类关系的类相当于私有的）
* `default`当前包下的所有类都可以访问（当没有写访问访问修饰符时默认时`default`，默认对同一包的其他类时公开的，不同包的其他类时私有的）
* `private `只能被当前类访问。

`Java`中，外部类只能是`public`或`default`，类的成员（包括内部类）的修饰符可以是四种修饰符的任意一种。

## 6、Integer

* 执行`Integer `a= 128，相当于`Integer a = Integer.valueOf(128)`，该过程称为自动装箱（基本类型自动装换为包装类的过程）。

* 在 Integer 中引⼊了 `IntegerCache `来缓存⼀定范围的值，`IntegerCache `默认情况下范围 为：`-128~127`。这个缓存范围时可以修改的，通过`JVM`启动参数： -`XX:AutoBoxCacheMax=<size> `来修改上限值.

## 7、最有效计算2乘以8

* 2 << 3。(左移 相当于乘以2的⼏次幂， n << m 相当于n乘2的m次幂)

* 进阶：通常情况下，可以认为位运算是性能最高的。

## 8、&和&&的区别

* `&&`：逻辑与运算符。当运算符左右两边的表达式都为 `true`，才返回 true。`同时`具有短路性，如果第 ⼀个表达式为 `false`，则直接返回 `false`。

* `&`：逻辑与运算符、按位与运算符。⽤于⼆进制的计算，只有对应的两个⼆进位均为`1`时，结果位才为`1 `，否则为`0`。

* 逻辑与运算符：`& `在⽤于逻辑与时，和 `&&` 的区别是不具有短路性。所在通常使⽤逻辑与运算符都会 使⽤ `&&`，⽽ `&` 更多的适⽤于位运算。

## 9、Java基本数据类型、String类型

* 8个：`byte、short、int、long、float、double、char、boolean`。
* `String`类不是基本数据类型，而且使用final修饰，不能被继承。
* 除了基本类型（primitive type），剩下的都是引用类型（reference type）。
* 基本数据类型：数据直接存储在栈上。
* 引用数据类型：数据存储在堆上，引用地址存储在栈上。

## 10、String和StringBuilder、StringBuffer的区别

* `String`：值被创建后就不能修改，任何对`String`的修改都会引发新的String对象生成。
* `StringBuilder`：值可以被修改，没有使⽤ `synchronized`，具有更⾼的性能，推荐优先使⽤（`StringBuffer`的非线性安全版）。
* `StringBuffer`：线程是安全的，值可以被修改，使⽤ `synchronized `来保证线程安全。

## 11、String s = "xyz" 和 String s = new String("xyz") 区别

* 两个语句都会先去字符串常量池中检查是否已经存在 “`xyz`”，如果有则直接使⽤，如果没有则会在常量池中创建 “`xyz`” 对象。
* `String s = new String("xyz") `还会通过 `new String() `在堆⾥创建⼀个内容与 "`xyz`" 相同的对象实例。
* 前者其实理解为被后者的所包含。

## 12、==和equals的区别

* `==`：运算符，用于比较基础类型变量和引用类型变量。
  * 基础类型变量：比较的的保存的值是否相同，类型不一定要相同。
  * 引用类型变量：比较的是两个对象的地址是否相同。
* `equals`：`Object `类中定义的⽅法，通常⽤于⽐较两个对象的值是否相等。
  * `equals `在 `Object `⽅法中其实等同于`==`，但是在实际的使⽤中，`equals `通常被重写⽤于⽐较两个对 象的值是否相同。

## 13、hashCode()和equals()的关系

当` a.equals(b) == true` 时，则 `a.hashCode() == b.hashCode()` 必然成⽴，反过来，当 `a.hashCode() == b.hashCode()` 时，`a.equals(b)` 不⼀定为` true`。

## 14、反射

* 反射：指运行状态中，任意一个类都能知道这个类的所有属性和方法；并且任意一个类都能调用它的任意一个方法；这种动态获取信息和调用对象方法的功能称为反射机制。

* 反射的四个核心类：

  * `java.lang.Class.java`：类对象
  * `java.lang.reflect.Constructor.java`：类的构造器对象； 
  * `java.lang.reflect.Method.java`：类的⽅法对象； 
  * `java.lang.reflect.Field.java`：类的属性对象；

* 反射作用

  * 操作因访问权限限制的属性和⽅法； 
  * 实现⾃定义注解；
  *  动态加载第三⽅jar包；
  * 按需加载类，节省编译和初始化`APK`的时间；

* 反射工作原理

  当一个`Java`项目编写完成之后，每个`java`文件都会被编译成`.class`文件，这些`Class`对象承载了这个类的所有信息，包括父类、接口、方法、属性等，这些`class`文件在程序运行的时候会被`ClassLoader`加载到虚拟机里面。当一个类被加载后，`Java`虚拟机会在内存中自动生产一个`Class`对象。我们通过`new`创建对象实际上是通过这些`Class`来创建。

反射的工作原理就是借助`Class.java`、`Constructor.java`、`Method.java`、`Field.java`这四个类，在程序运行的时动态访问和修改任何类的行为和状态。

## 15、深拷贝和浅拷贝的区别

* 两种数据类型
  * 基本数据类型：数据直接存储在栈里面。
  * 引用数据类型：数据存储在堆中，引用地址存储在栈中。
* 浅拷贝
  * 基础数据类型：直接复制数据值。
  * 引用数据类型：只是复制了对象的引用地址，新旧对象指向同一个地址（共用同一个内存），修改其中一个对象的值，另外一个也跟着改变。

* 深拷贝
  * 基础数据类型：直接复制数据值。
  * 引用数据类型：创建一个新的内存空间，里面复制相同的对象，新旧对象不共享内存，修改其中一个对象的值，不会影响另外一个。


> 深拷贝比浅拷贝的速度慢并且花销较大。

## 16、并发与并行的区别

* 并发：两个或多个事件在同一个事件间隔发生。
* 并行：两个或多个事件在同一时刻发生

**并行**实际上是，同一时刻做多件事情；**并发**在同一时刻只会做一件事情，只是将事件切碎，交替做多件事情。

**并行**在多个处理器中存在，**并发**可以在单处理器和多处理器中都存在，**并发**能够在单处理器系统中存在是因为**并发**是**并⾏**的假象，**并⾏**要求程序能够同时执⾏多个操作，⽽**并发**只是要求程序假装同时执⾏多个操作（每个⼩时间⽚执⾏⼀个操作，多个操作快速切换执⾏）。

当系统有⼀个以上 `CPU `时，则线程的操作有可能⾮并发。当⼀个 `CPU `执⾏⼀个线程时，另⼀个 `CPU `可以执⾏另⼀个线程，两个线程互不抢占 `CPU `资源，可以同时进⾏，这种⽅式我们称之为并⾏ （`Parallel`）。 

**并发编程**的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能。

## 17、值传递和引用传递

* 值传递：当⼀个对象被当作参数传递到⼀个⽅法后，此⽅法可改变这个对象的属性，并可返回变化后的结果。（**值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容**）
* 引用传递：”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向同一块内存地址，对形参的操作会影响的真实内容。

> Java 中只有值传递，对于对象参数，值的内容是对象的引⽤。
>
> **如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。**
>
> **如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。**

## 18、重载（Overload）和重写（Override）的区别

方法的重载和重写都是实现多态的方式，区别是重载实现的是编译时多态，重写实现的是运行时多态。

* 重载：一个类里面可以多个同名的方法，但其参数列表不同（类型不同、个数不同，顺序不同）
* 重写：发生在子类与父类之间，子类对父类的方法进行重写，参数不变，返回值类型可以的不同，但必须是父类返回值的派生类。（即方法和参数不变，逻辑重写）

重写的好处：子类可以根据需要，定义自己的行为。

> 注意：
>
> Constructor（构造器）不能被重写（override），但可以被重载（overload），所以一个类中可以有多个构造函数。
>
> ⽅法的返回值只是作为⽅法运⾏之后的⼀个“状态”，但是并不是所有调⽤都关注返回值，所以不能 将返回值作为重载的唯⼀区分条件。

## 19、Java 成员变量与静态变量的区别

* 成员变量存在于堆内存中；静态变量存在于方法区中
* 成员变量与对象共存亡，随对象创建而存在，随对象被回收而释放；静态变量与类共存亡，随类加载而存在，随类被消失而消失。
* 成员变量所属于对象，称为实例变量；静态变量所属于类，称为类变量。
* 成员变量只能被对象调用；静态变量可以被对象调用，也可以被类调用。

## 20、是否可以从⼀个静态（static）⽅法内部发出对⾮静态（non-static）⽅法的调⽤

两种情况，发出调用时是否显示创建了对象实例 。

* 没有显示创建对象实例：不可以发起调用，非静态方法只能被对象所调用，静态方法可以通过对象调用，也可以通过类名调用，所以静态方法被调用时，可能没有创建任何对象实例。因此通过静态⽅法内部发出对⾮静态⽅法的调⽤，此时可能⽆法知道⾮静态⽅法属于哪个对象。
* 显⽰创建对象实例：可以发起调⽤，在静态⽅法中显⽰的创建对象实例，则可以正常的调⽤。

## 21、初始化

* 静态变量只会初始化（执⾏）⼀次。 
* 当有⽗类时，完整的初始化顺序为：⽗类静态变量（静态代码块）->⼦类静态变量（静态代码 块）->⽗类⾮静态变量（⾮静态代码块）->⽗类构造器 ->⼦类⾮静态变量（⾮静态代码块）->⼦类构 造器 。

## 22、抽象类(abstract class)与接口(interface)的区别

* 抽象类只能单继承；接口可以多实现。
* 抽象类可以有构造方法；接口不能有构造方法。
* 抽象类可以有成员变量；接口没有成员变量，只有常量（默认就是 `public static final`）。
* 抽象类中可以包含⾮抽象的⽅法，在 Java 7 之前接⼝中的所有⽅法都是抽象的，在 Java 8 之 后，接⼝⽀持⾮抽象⽅法：default ⽅法、静态⽅法等。Java 9 ⽀持私有⽅法、私有静态⽅法。
* 抽象类中的抽象⽅法类型可以是任意修饰符，Java 8 之前接⼝中的⽅法只能是 public 类型，Java 9 ⽀持 private 类型。

设计思想的区别

* 接口是自上而下的抽象的过程，接口规范了某些行为，是对某一行为的抽象。需要某个行为时，就去实现某个接口，具体怎么实现，取决于自己。
* 抽象类是自下而上的抽象过程，抽象类提供了通用实现，是对某一事物的抽象。在写实现类时，发现某些实现类都具有几乎相同的实现，因此将这些相同的实现抽取出来成为抽象类，然后有一些差异点，可以通过提供抽象方法来支持自定义实现。

> 网上有个说法
>
> 普通类像亲爹，他有什么都是你的。
>
> 抽象类像叔伯，有一部分会给你，还能指导你做事的方法。
>
> 接口像干爹，可以给你指引方法，但是做成什么样的自己努力。

## 23、final关键字的用法

* 修饰类：不能作为父类被继承。一个类不能同时被声明为`abstract`和`final`。
* 修饰方法：不能被子类重写。
* 修饰变量：该变量在声明时必须给定初值，而且以后只能读取，不能修改。若变量是对象，则引用地址不可改，但对象的属性可以修改。

## 24、final、finally、finalize的区别

它们三是完全不想关的，只是有点像

* `final`如上。
* `finally`：是对Java异常处理机制的最佳补充，通常搭配try、catch使用，用于存放那些无论是否出现异常都会执行的代码 。在实际使用中，通常用来释放锁、数据库连接等资源，把资源 释放方法放到`finally`中，可以大程度上降低程序出错率。
* `finalize`：`Object`中的方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。但该方法仅作了解，在`Java9`中该方法已经被弃用，并添加新的`java.lang.ref.Cleaner`，提供了更加灵活有效的方法来释放资源。

## 25、try、catch、finally的使用

`try`、`catch`、`finally `的基础⽤法，在 `return `前会先执⾏ `finally `语句 块，所以是先输出 `finally `⾥的结果，再输出`try`或`catch`里面的`return`。(finally ⾥⾯使⽤ return 仅存在于⾯试题中，实际开发中千万不要这么⽤。)
