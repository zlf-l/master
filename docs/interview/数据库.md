# 数据库

## 1.MySql的存储引擎有哪些，区别是什么

MySQL常见的三种存储引擎为InnoDB、MyISAM和MEMORY。

**事务安全**：InnoDB支持事务安全，MyISAM和MEMORY两个不支持。

**存储限制**：InnoDB有64TB的存储限制，MyISAM和MEMORY要是具体情况而定。

**空间使用**：InnoDB对空间使用程度较高，MyISAM和MEMORY对空间使用程度较低。

**内存使用**：InnoDB和MEMORY对内存使用程度较高，MyISAM对内存使用程度较低。

**插入数据的速度**：InnoDB插入数据的速度较低，MyISAM和MEMORY插入数据的速度较高。

**对外键的支持**：InnoDB对外键支持情况较好，MyISAM和MEMORY两个不支持外键。

## 2.触发器的作用

触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

## 3.什么是存储过程用什么来调用

存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。

> 调用：
>
> 可以用一个命令对象来调用存储过程。
>
> 可以供外部程序调用，比如：java程序。

## 4.存储过程的优缺点。

优点：

1）存储过程是预编译过的，执行效率高。

2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。

3）安全性高，执行存储过程需要有一定权限的用户。

4）存储过程可以重复使用，可减少数据库开发人员的工作量。

缺点：移植性差

## 5.SQL优化的具体操作

1、尽量避免使用select *，返回无用的字段会降低查询效率。

优化方式：使用具体的字段代替 *，只返回使用到的字段。

2、尽量避免使用in和notin，会导致数据库引擎放弃索引进行全表扫描。

优化方式：如果是连续数值，可以用between代替。如果是子查询，可以用exists代替。

3、尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。

优化方式：尽量在字段后面使用模糊查询。

4、尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。

优化方式：可以给字段添加默认值0，对0值进行判断。

## 6.什么叫视图、游标是什么

**视图**：是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。

**游标**：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

## 7.视图的优缺点

**优点**：

对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。

用户通过简单的查询可以从复杂查询中得到结果。

维护数据的独立性，试图可从多个表检索数据。

对于相同的数据可产生不同的视图。

**缺点**：

查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据

## 8.事务的四个特性

原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。

隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

持久性（Durability）：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

## 9.数据库乐观锁，悲观锁的区别，怎么实现

悲观锁（PessimisticLock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞挂起直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁。

乐观锁（OptimisticLock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改数据，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，乐观锁适用于多读的应用类型，这样可以提高吞吐量。

两种锁各有优缺点，乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样就可以省去锁的开销，加大系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。

## 10.事务的并发问题

1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

2、不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。

3、幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。

## 11.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景

**事务处理上方面**

MyISAM：强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。

InnoDB：提供事务支持事务，外部键等高级数据库功能。具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe(ACID compliant))型表。

**锁级别**

MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。

InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。

## 12.非关系型数据库和关系型数据库区别，优势比较

**非关系型数据库的优势**：

**性能**：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。

**可扩展性**：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。关系型数据库的优势：

**复杂查询**：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。

**事务支持**：使得对于安全性能很高的数据访问要求得以实现。

## 13.数据库的五大范式

* 第一范式：(确保每列保持原子性)所有字段值都是不可分解的原子值。

  第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

  第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。

  上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。

* 第二范式：(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

  第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

  比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。

* 第三范式：(确保每列都和主键列直接相关，而不是间接相关)数据表中的每一列数据都和主键直接相关，而不能间接相关。

  第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

  比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。

  > BCNF：符合3NF，并且，主属性不依赖于主属性。
  >
  > 若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。
  >
  > 通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。
  >
  > BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。
  >
  > 还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。
  >
  > 一般，一个数据库设计符合3NF或BCNF就可以了。

* 第四范式：要求把同一表内的多对多关系删除。
* 第五范式：从最终结构重新建立原始结构。

## 14.什么是内连接、外连接、交叉连结、笛卡尔积等

**内连接**：只连接匹配的行

**左外连接**：包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行

**右外连接**：包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行

例如1：

SELECT a.，b. FROM luntan LEFT JOIN usertable as b ON a.username = b.username

例如2：

SELECT a.，b. FROM city as a FULL OUTER JOIN user as b ON a.username = b.username

**全外连接**：包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。

**交叉连接**：生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配

## 15.SQL语言分类

数据查询语言DQL

数据操纵语言DML

数据定义语言DDL

数据控制语言DCL

## 16.count(*)、count(1)、count(column)的区别

count(*)对行的数目进行计算，包含NULL

count(column)对特定的列的值具有的行数进行计算，不包含NULL值。

count()还有一种使用方式，count(1)这个用法和count(*)的结果是一样的。

## 17.什么是索引

数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

## 18.索引的作用

协助快速查询、更新数据库表中数据。

为表设置索引要付出代价的：

* 增加了数据库的存储空间

* 在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。

## 19.索引的优缺点

创建索引可以大大提高系统的性能（优点）：

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时

间。

5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

增加索引也有许多不利的方面(缺点)：

1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

## 20.什么样的字段适合建索引

唯一、不为空、经常被查询的字段

## 21.Hash索引和B+树索引的区别

hash索引，等值查询效率高，不能排序，不能进行范围查询；B+树数据有序，范围查询

## 22.MySQL三种锁的级别

**表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

**行级锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

**页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

## 23.为什么不都用Hash索引而使用B+树索引

索引查找过程中就要产生磁盘I/O消耗，主要看IO次数，和磁盘存取原理有关。根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入局部性原理与磁盘预读

## 24.B树和B+树的区别

B**树**：每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。

**B+树**：所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B树的非终节点也包含需要查找的有效信息)

## 25.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引

**B+的磁盘读写代价更低**

B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

**B+tree的查询效率更加稳定**

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## 26.聚集索引和非聚集索引区别

**聚合索引**(clustered index)：

聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a，ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。

**非聚合索引**(nonclustered index)：

非聚集索引指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。

非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。

**根本区别**：

聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。

