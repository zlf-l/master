# 多线程

## 1.Java创建线程之后，直接调用start()方法和run()的区别

启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。

## 2.线程B怎么知道线程A修改了变量

volatile修饰变量

synchronized修饰修改变量的方法

wait/notify

while轮询

## 3.synchronized和Volatile、CAS比较

synchronized是悲观锁，属于抢占式，会引起其他线程阻塞。

volatile提供多线程共享变量可见性和禁止指令重排序优化。

CAS是基于冲突检测的乐观锁（非阻塞）

## 4.线程间通信，wait和notify的理解和使用

wait和notify必须配合synchronized关键字使用。

wait方法释放锁，notify方法不释放锁。

还要注意一点就是涉及到线程之间的通信，就肯定会用到validate修饰。

## 5.定时线程的使用

普通线程死循环

使用定时器timer

使用定时调度线程池ScheduledExecutorService

## 6.线程同步的方法

wait()：使一个线程处于等待状态，并且释放所持有的对象的lock。

sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。

notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。

notityAll()：唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

## 7.进程和线程的区别

1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。

2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。

3、拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。

4、系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。

## 8.什么叫线程安全

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。

## 9.线程的几种状态

1、新建状态(New)：新创建了一个线程对象。

2、就绪状态(Runnable)：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于”可运行线程池”中，变得可运行，只等待获取[CPU](http：//product.it168.com/list/b/0217_1.shtml)的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。

3、运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码。

4、阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

> 阻塞的情况分三种：
>
> (1)、等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入”等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，
>
> (2)、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入”锁池”中。
>
> (3)、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

5、死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

## 10.volatile变量和atomic变量有什么不同

volatile变量和atomic变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用volatile修饰count变量那么count++操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。

## 11.Java中什么是静态条件

竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。

## 12.Java中如何停止一个线程

Java提供了很丰富的API但没有为停止线程提供API。JDK1.0本来有一些像stop()，suspend()和resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后JavaAPI的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run()或者call()方法执行完的时候线程会自动结束，如果要手动结束一个线程，你可以用volatile布尔变量来退出run()方法的循环或者是取消任务来中断线程。

## 13.线程池的优点

重用存在的线程，减少对象创建销毁的开销。

可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。

提供定时执行、定期执行、单线程、并发数控制等功能。

## 14.volatile的理解

volatile关键字的两层语义

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2. 禁止进行指令重排序。

用volatile修饰之后，变量的操作：

1. 使用volatile关键字会强制将修改的值立即写入主存；
2. 使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
3. 由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。

## 15.实现多线程有几种方式

在语言层面有两种方式。java.lang.Thread类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread类或者直接调用Runnable接口来重写run()方法实现线程。

## 16.Java中notify和notifyAll有什么区别

notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。

## 17.什么是乐观锁和悲观锁

乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。

悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。

## 18.线程的创建方式

继承Thread类

实现Runnable接口

实现Callable接口方式四：使用线程池的方式

## 19.线程池的作用

创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，JavaAPI提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。

## 20.wait和sleep的区别

sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。

wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

## 21.产生死锁的条件

互斥条件：一个资源每次只能被一个进程使用。

请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。

循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

## 22.请写出实现线程安全的几种方式

使用同步代码块

使用同步方法

使用ReentrantLock

## 23.守护线程是什么、它和非守护线程的区别

程序运行完毕，jvm会等待非守护线程完成后关闭，但是jvm不会等待守护线程.守护线程最典型的例子就是GC线程.

## 24.什么是多线程的上下文切换

多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程.

## 25.Callable和Runnable的区别是什么

两者都能用来编写多线程，但实现Callable接口的任务线程能返回执行结果，而实现Runnable接口的任务线程不能返回结果.Callable通常需要和Future/FutureTask结合使用，用于获取异步计算结果.

## 26.线程阻塞有哪些原因

1、sleep()允许指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU时间，指定的时间一过，线程重新进入可执行状态。典型地，sleep()被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止2、suspend()和resume()两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。典型地，suspend()和resume()被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用resume()使其恢复。

3、yield()使当前线程放弃当前已经分得的CPU时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得CPU时间。调用yield()的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程

4、wait()和notify()	两个方法配套使用，wait()使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的notify()被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的notify()被调用.

## 27.synchronized和Lock的区别

主要相同点：Lock能完成synchronized所实现的所有功能

主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。

## 28.ThreadLocal是什么有什么作用

ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。

简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。

## 29.交互方式分为同步和异步两种

同步交互：指发送一个请求，需要等待返回，然后才能够发送下一个请求，有个等待过程；

异步交互：指发送一个请求，不需要等待返回，随时可以再发送下一个请求，即不需要等待。

区别：一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式。

## 30.什么是线程

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速

## 31.什么是FutureTask

在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。

## 32.Java中interrupted和isInterruptedd方法的区别

interrupted()和isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用[静态方法](http：//java67.blogspot.com/2012/11/what-is-static-class-variable-method.html)Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。

## 33.死锁的原因

是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环。例如：线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。

默认的锁申请操作是阻塞的。所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。

## 34.什么是自旋

很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。

## 35.怎么唤醒一个阻塞的线程

如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。

## 36.如果提交任务时，线程池队列已满，这时会发生什么

许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’ssubmit()方法将会抛出一个RejectedExecutionException异常。

## 37.什么是线程局部变量

线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如web服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java应用就存在内存泄露的风险。

## 38.使用volatile关键字的场景

synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。

通常来说，使用volatile必须具备以下2个条件：

* 对变量的写操作不依赖于当前值

* 该变量没有包含在具有其他变量的不变式中

## 39.线程池的工作原理，几个重要参数

工作原理：

1、线程在有任务的时候会创建核心的线程数corePoolSize

2、当线程满了（有任务但是线程被使用完）不会立即扩容,而是放到阻塞队列中,当阻塞队列满了之后才会继续创建线程。

3、如果队列满了,线程数达到最大线程数则会执行拒绝策略。

4、当线程数大于核心线程数事,超过KeepAliveTime(闲置时间),线程会被回收,最终会保持corePoolSize个线程。

重要参数：

ThreadPoolExecutor(int corePoolSize，int maximumPoolSize，long keepAliveTime，TimeUnit unit，BlockingQueue workQueue，ThreadFactory threadFactory，RejectedExecutionHandler handler)

> 参数说明：
>
> corePoolSize核心线程数
>
> maximumPoolSize最大线程数，一般大于等于核心线程数
>
> keepAliveTime线程存活时间(针对最大线程数大于核心线程数时，非核心线程)
>
> unit存活时间单位，和线程存活时间配套使用
>
> workQueue任务队列
>
> threadFactory创建线程的工程
>
> handler拒绝策略

## 40.线程池的类型

五种线程池：

ExecutorServic threadPool=null;

* threadPool=Executors.newCachedThreadPool(); 

  有缓冲的线程池，线程数JVM控制

* threadPool=Executors.newFixedThreadPool(3);  

  固定大小的线程池

* threadPool=Executors.newScheduledThreadPool(2);

* threadPool=Executors.newSingleThreadExecutor();  

  单线程的线程池，只有一个线程在工作

* threadPool=newThreadPoolExecutor();  

  默认线程池，可控制参数比较多

## 41.线程池的阻塞队列有哪些

三种阻塞队列：

BlockingQueue<Runnable> workQueue=null;

* workQueue=newArrayBlockingQueue<>(5);

  基于数组的先进先出队列，有界

* workQueue=newLinkedBlockingQueue<>();

  基于链表的先进先出队列，无界

* workQueue=newSynchronousQueue<>();

  无缓冲的等待队列，无界

## 42.线程池的拒绝策略都有哪些

四种拒绝策略

等待队列已经排满了，再也塞不下新任务，同时线程池中线程也已经达到maximumPoolSize数量，无法继续为新任务服务，这个时候就需要使用拒绝策略来处理。

RejectedExecutionHandler rejected=null;

* rejected=newThreadPoolExecutor.AbortPolicy();

  默认，队列满了丢任务抛出异常，直接抛出RejectedExecutionException异常阻止系统正常运行。

* rejected=newThreadPoolExecutor.DiscardPolicy();

  队列满了丢任务不异常，直接丢弃任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种方案。

* rejected=newThreadPoolExecutor.DiscardOldestPolicy();

  将最早进入队列的任务删，之后再尝试加入队列，抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。

* rejected=newThreadPoolExecutor.CallerRunsPolicy();

  如果添加到线程池失败，那么主线程会自己去执行该任务，调用者运行”一种调节机制，该策略既不会丢弃任务，也不会抛出异常，而是将某些任务回退给调用者，从而降低新任务的流量。
