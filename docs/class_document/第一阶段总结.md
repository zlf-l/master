# 第一阶段总结

## OOP语法

### 类与对象
类是对事物普遍状态和行为的抽象(动词)，而对象是这种抽象(名词)的具体表现形式中的某一个个例

我们在封装一个类的时候，使用`Field`属性（全局变量）来表示状态，用`Method`方法来表示行为
类可以被当作一个模板（母版），来创建出非常多的实例，这些实例有着大致相同的特点，但是在具体的状态和行为上是有细微区别的

### 封装
所谓的封装就是把近似的内容集成在一块，对外提供相应的数据和服务

抽象，即为“关注主要的，忽略次要的”（隐藏不必要的细节，降低外部调用复杂度）

- 对于类而言，主要的即为共有的
- 方法，主要的是输入参数和返回值

### 继承
所谓继承，是用来做类型扩展的，扩展类不光是可以获取到原先类型的各种特性，同时还可以延展出自有特性。

语法注意事项：
- 父类型中只有非私有的属性和方法，子类才能直接使用
- 对于那些私有的属性，如果提供了公共的getter和setter，子类是可以间接访问和修改的
- 任何类型如果没有直接声明父类型，都有一个默认的父类Object
- 所有类型只能有一个直接父类（单根继承）

### 多态
一个行为在不同条件下有不同的表现方式或者执行结果

实现多态有：
- 继承
- 接口实现
- 方法重写、重载

多态最常见的表现方式： Parent parent = new Child();
- parent可以调用哪些方法，由Parent类型中声明的方法决定
- parent调用方法后，具体的执行方式，由Child中的方法体决定（如果Child中重写了Parent中的方法，执行时以Child重写逻辑为准）

### 抽象类
一般来说，类中有一些方法无法提供具体实现，那么我们会声明这个类为抽象的，这个抽象类的存在就是为了被扩展继承的

语法细节：
- 类中只要有一个方法为抽象的，那么这个类必须是抽象的
- 类中没有抽象方法，这个类也可以被声明为抽象的（不想让它实例化）
- 任何子类在继承抽象类的时候，只要有一个抽象方法没有实现，那么这个子类也必须继续保持抽象

抽象类主要用来被继承，它是为了提炼公共的状态和行为，哪怕这些行为是抽象的

### 接口
接口即为一个或多个行为的契约（约定输入、输出），其实就是为了规定数据交换（交易）的规则，在这份契约中，对于这个行为并不需要明确指定，因此是抽象的

语法注意事项：
- 接口中的变量都是常量(public final static)
- 一个类可以实现(implements)多个接口，但是接口互相之间是继承关系(extends)
- 接口中可以没有一个抽象方法(空接口)
- 接口中也可以有具体的方法(默认方法)

接口主要是用来解除耦合关系的，即某一个具体类型和相应具体行为之间的关联关系

一旦订立好了契约(这个行为的公共行业标准，接口)，就可以让这个类型依赖一个抽象的接口，在具体运行的时候，才会接驳上这个行为的实现方式

### 类型转换
自动类型转换
- 把子类型转换为父类型
- 基本类型中，把存储长度小的转化为长度更大的（数字类型间转换较为多见）
- 装箱，基本类型转换为对应的封装类型
- 拆箱，封装类型转换为基本类型

强制类型转换
- 把父类型转换为子类型
- 基本类型中，把存储长度大的转化为长度小的（数字类型间转换较为多见）

### 重写与重载
重载
- 一般在同一个类中
- 方法名相同，参数列表不相同（顺序、类型、个数）
- 返回类型、方法修饰符、抛出异常类型三者的不一样，都无法独立形成重载

重写
- 一般发生在父子类之间
- 方法的签名是一样（方法名、参数），但是具体实现不一样
- 在重写时，方法修饰符可以放大，返回类型只能更具体，抛出的异常类型只能更具体

### throw 与 throws
throw 是手工抛出异常的动作
throws 是声明该方法有可能会抛出某种类型的异常

### 异常
Throwable是所有“错误”的父类型
- Exception 程序员逻辑造成的错误的统称
  - 运行时异常 不受检测异常(编译器强制性检测)，可以理解为不严重的异常，方法声明时无需throws
  - 非运行时异常 受检测异常，理解为较严重错误，程序员必须要处理的(try-catch / throws)
- Error 系统级(JDK)，程序员无法修复和补偿的

try-catch
- try-catch try-finally
- 使用catch捕获异常的时候，只能捕获声明的异常类型及其子类型
- 在捕获异常的时候，可以并列捕获(if - else if - else fi)，但是建议辈分从小到大排列
- 在捕获异常的时候，可以使用 “AException a| BException b”，两个异常一般是兄弟关系，或者没有血缘关系

### final finally finalize
final
- 修饰类，不能被继承
- 修饰方法，不能重写
- 修饰属性
  - 基本类型，值不能修改
  - 引用类型，地址不能修改

finally
- 表示无论是否发生异常，都最终会执行
- 如果有return，以finally为准（不建议这样写）

finalize
- JVM在回收对象之前，会调用该方法
- JVM的垃圾回收

## Java高级编程
### 常用类 java.lang
== 和 equals
- 前者比较的是地址，用来衡量两个对象是否完全相等
- 用来让我修改、调整“相等”的尺度的，在默认情况下，equals是地址比较
- String、Number它们比较的是值

### IO流
分类
- 根据方向来分
  - 输入
  - 输出
- 根据基本的操作单位
  - 字节流(最小单位)，命名输入和输出都是以Stream结尾
  - 字符流，输入以Reader结尾，输出以Writer结尾
- 根据是否能直接与资源打交道
  - 处理流
  - 节点流 BufferedXXXX

### 网络编程
TCP协议
- 有主次之分，两个端点之间，身份分为服务器(ServerSocket)和客户端(Socket)
- 由于有着一套完善的通讯握手协议(双工)
- 在数据的交换过程中，能保障数据帧的有序、安全、一致

UDP协议
- 通讯的两者之间地位完全平等，因为双方的工具、资源完全一致的 DatagramSocket DatagramPacket
- 在发送数据和接收数据的时候，完全不用理会对方是否能正常工作
- 由于是单工协议，所以数据传递的速度快于TCP协议

HTTP协议 - 应用层协议

### 集合框架

Collection
- 能存放多个元素
- 提供基本的CRUD方法
- 能使用迭代器获取其中的元素

List
- 有序(插入)
- 可存放重复元素
- 实现类
  - ArrayList
    - 基于数据实现的
    - 随机查找速度快，随机删除、插入速度慢（索引等效于内存地址）
  - LinkedList
    - 基于双向链表实现（整个集合是由节点组成的，每一个节点除开保存自己的数据以外，还有一个引用指向前一个节点，一个引用指向后一个节点）
    - 随即查找速度慢，随机删除、插入的速度快
  - Vector 线程安全
  - CopyOnWriteArrayList 线程安全的，通过显式锁实现同步化的

Set
- 不允许重复元素
- 实现类
  - HashSet
    - 无序的
    - 基于HashMap的key实现的
  - TreeSet 大小有序
  - LinkedHashSet 插入有序的
  - CopyOnWriteArraySet 线程安全的

Map
- 键值对的数据结构
- key不能重复，value可以重复
- 实现类
  - HashMap
    - 基于数组实现，数组的元素是链表
    - 如何保障key不能重复：主要是比较hash和equals
  - TreeMap key是大小有序
  - LinkedHashMap key插入有序
  - Hashtable 线程安全
  - ConcurrentHashMap 线程安全

### 多线程

生命周期

创建线程的几种方式

wait sleep的区别
- 都可以制造阻塞
- sleep不会释放锁
- wait会释放锁

死锁
- 持续争抢某一些资源
- 自己手头上一直持有对方想要资源，但是不释放

*生产消费者模式

